##JS深入
	
###左右查询；
	左查询:在整个作用域链中没有找到变量的声明，这全局作用域会主动给你声明一份;
	右查询：右查询:在整个作用域链中，如果没有目标变量的声明。就会报错ReferenceError
	提升:
		1.函数的提升优于变量的提升
		2.函数的提升是整体的提升,变量的提升是声明的提升
		3.提升是指提升到本层作用域的最顶层
		4.在块内部不要定义函数、
		   变量的提升不会理会if else这种条件暗示


###this的机制问题：
	主线:函数的调用位置上的调用形式！！！
	
	独立调用   ---->  默认绑定规则  ----> this绑给window
						 在严格模式底下会绑给undefined
							 
	对象点的形式  -----> 隐式绑定规则  ----> this绑给最近那个调用对象
			隐式丢失:
				以隐式绑定的形式去赋值或传参，最终使用独立调用形式去调用
			this使用了默认绑定规则，导致this绑给了window，
				违背了开发者在赋值和传参时的意图
									
	call apply bind ---->   显示绑定规则  ----> this绑给指定的对象
				bind:硬绑定函数
		它可以为目标函数返回一个硬绑定函数，
			不管硬绑定函数使用何种形式调用，目标函数的
					this永远为指定的对象。
								
	new 调用---->  new绑定 -----> this绑给构造出来的实例对象
				怎么将伪数组转成真正的数组
				Aarry.apply(null,{})
								
	绑定的优先级
		new绑定 > 显示绑定 > 隐式绑定 > 默认绑定
	

	
	

	